{"body":"## DESCRIPTION\r\nlibcircle is an API for distributing embarrassingly parallel workloads using self-stabilization. Details on the algorithms used may be found at <http://dl.acm.org/citation.cfm?id=2389114>.\r\n\r\n## DEPENDENCIES\r\n* Open MPI  <http://www.open-mpi.org/>\r\n\r\n## API INFORMATION\r\nThe basic program flow when using libcircle is the following:\r\n\r\n1. Define callbacks which enqueue or dequeue strings from the queue.\r\n2. Execute the program.\r\n\r\n```C\r\n#include <libcircle.h>\r\n\r\n/* An example of a create callback defined by your program */\r\nvoid my_create_some_work(CIRCLE_handle *handle)\r\n{\r\n    /*\r\n     * This is where you should generate work that needs to be processed.\r\n     * For example, if your goal is to lstat files on a large filesystem,\r\n     * this is where you would readdir() and and enqueue directory names.\r\n     *\r\n     * This should be a small amount of work. For example, only enqueue the\r\n     * filenames from a single directory.\r\n     */\r\n    while((data_to_process = readdir(...)) != NULL)\r\n    {\r\n        handle->enqueue(data_to_process);\r\n    }\r\n}\r\n\r\n/* An example of a process callback defined by your program. */\r\nvoid my_process_some_work(CIRCLE_handle *handle)\r\n{\r\n    /*\r\n     * This is where work should be processed. For example, this is where you\r\n     * should lstat one of the files which was placed on the queue by your\r\n     * create_some_work callback. Again, you should try to keep this short and\r\n     * block as little as possible.\r\n     */\r\n    handle->dequeue(&my_data);\r\n    ...\r\n    finished_work = lstat(my_data, ...);\r\n    ...\r\n    store_in_database(finished_work);\r\n}\r\n\r\n/*\r\n * Initialize state required by libcircle. Arguments should be those passed in\r\n * by the launching process. argc is a pointer to the number of arguments,\r\n * argv is the argument vector. The return value is the MPI rank of the current\r\n * process.\r\n */\r\nint rank = CIRCLE_init(&argc, argv);\r\n\r\n/*\r\n * Processing and creating work is done through callbacks. Here's how we tell\r\n * libcircle about our function which creates the initial work. For MPI nerds,\r\n * this is your rank 0 process.\r\n */\r\nCIRCLE_cb_create(&my_create_some_work);\r\n\r\n/*\r\n * After you give libcircle a way to create work, you need to tell it how that\r\n * work should be processed.\r\n */\r\nCIRCLE_cb_process(&my_process_some_work);\r\n\r\n/*\r\n * Now that everything is setup, lets execute everything.\r\n */\r\nCIRCLE_begin();\r\n\r\n/*\r\n * Finally, give libcircle a chance to clean up after itself.\r\n */\r\nCIRCLE_finalize();\r\n```\r\n","name":"libcircle","google":"","tagline":"distributed self-stabilization made easy","note":"Don't delete this file! It's used internally to help with page regeneration."}