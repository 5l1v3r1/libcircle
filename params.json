{"name":"Libcircle","body":"Dependencies\r\n------------\r\n* Open MPI  <http://www.open-mpi.org/>\r\n\r\nCompile and install\r\n-------------------\r\n```\r\n./configure\r\nmake all check\r\nsudo make install\r\n```\r\n\r\nTo enable output from libcircle (including fatal errors), run configure with\r\n\"--enable-loglevel=number\" where \"number\" is one of the following options:\r\n\r\n* \"1\" fatal errors only.\r\n* \"2\" errors and lower log levels.\r\n* \"3\" warnings and lower log levels.\r\n* \"4\" info messages on internal operations and lower log levels.\r\n* \"5\" fine grained debug messages and lower log levels.\r\n\r\nRPM Build and Install\r\n---------------------\r\nTo build an RPM, use the following instructions:\r\n\r\n1. ```rpmbuild -ta libcircle-<version>-<release>.tgz```\r\n2. ```rpm --install <the appropriate RPM files>```\r\n\r\nDeveloper API Information\r\n-------------------------\r\nThe basic program flow when using libcircle is the following:\r\n\r\n1. Define callbacks which enqueue or dequeue strings from the queue.\r\n2. Execute the program.\r\n\r\n```C\r\n#include <libcircle.h>\r\n\r\n/* An example of a create callback defined by your program */\r\nvoid my_create_some_work(CIRCLE_handle *handle)\r\n{\r\n    /*\r\n     * This is where you should generate work that needs to be processed.\r\n     * For example, if your goal is to lstat files on a large filesystem,\r\n     * this is where you would readdir() and and enqueue directory names.\r\n     *\r\n     * This should be a small amount of work. For example, only enqueue the\r\n     * filenames from a single directory.\r\n     */\r\n    while((data_to_process = readdir(...)) != NULL)\r\n    {\r\n        handle->enqueue(data_to_process);\r\n    }\r\n}\r\n\r\n/* An example of a process callback defined by your program. */\r\nvoid my_process_some_work(CIRCLE_handle *handle)\r\n{\r\n    /*\r\n     * This is where work should be processed. For example, this is where you\r\n     * should lstat one of the files which was placed on the queue by your\r\n     * create_some_work callback. Again, you should try to keep this short and\r\n     * block as little as possible.\r\n     */\r\n    handle->dequeue(&my_data);\r\n    ...\r\n    finished_work = lstat(my_data, ...);\r\n    ...\r\n    store_in_database(finished_work);\r\n}\r\n\r\n/*\r\n * Initialize state required by libcircle. Arguments should be those passed in\r\n * by the launching process. argc is a pointer to the number of arguments,\r\n * argv is the argument vector. The return value is the MPI rank of the current\r\n * process.\r\n */\r\nint rank = CIRCLE_init(&argc, argv);\r\n\r\n/*\r\n * Processing and creating work is done through callbacks. Here's how we tell\r\n * libcircle about our function which creates the initial work. For MPI nerds,\r\n * this is your rank 0 process.\r\n */\r\nCIRCLE_cb_create(&my_create_some_work);\r\n\r\n/*\r\n * After you give libcircle a way to create work, you need to tell it how that\r\n * work should be processed.\r\n */\r\nCIRCLE_cb_process(&my_process_some_work);\r\n\r\n/*\r\n * Now that everything is setup, lets execute everything.\r\n */\r\nCIRCLE_begin();\r\n\r\n/*\r\n * Finally, give libcircle a chance to clean up after itself.\r\n */\r\nCIRCLE_finalize();\r\n```","tagline":"An API to provide an efficient distributed queue on a cluster. Libcircle is currently used in production to quickly traverse and perform operations on a file tree which contains several hundred-million file nodes. It has been tested at scale on several top500.org computers.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}